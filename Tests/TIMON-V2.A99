;******************************************************
;						      *
; TMS9900 MONITOR, INSTANT ASSEMBLER AND DISASSEMBLER *
;						      *
;******************************************************
;
;	FILE NAME:	TIMON.A99
;	TITLE=: 	TMS9900 MONITOR V2.1 <<
;	AUTHOR: 	ALEX CAMERON
;	WRITTEN:	1983 TO 2019
;
;******************************************************
;
; Comments:	1.The monitor is set at a baud rate 19200 - but can easily be altered
;		2.TMR9902 if fed by a 4Mhz Clock
;
; Commands.   The following commands are available:
;
;		Q (QBOOT), U (HEXLOAD),G (GO TO) M(MOVE) F(FIND),O (OUTPUT), W (WORK SPACE),R (REGISTERS),P(PRINT)
;		X(XCUTE),L(LOWW),H(SETBP),S(STEP),T(TRACE),/(CHAR),.(INSTANT),O(OPEN)
;*********************************************************
;
TRUE	EQU	1
FALSE	EQU	0
LOWRAM	EQU	TRUE			
HIRAM   EQU 	FALSE
;***************************
;DEFINE REGISTERS
;****************************
R0	EQU	0
R1	EQU	1
R2	EQU	2
R3	EQU	3
R4	EQU	4
R5	EQU	5
R6	EQU	6
R7	EQU	7
R8	EQU	8
R9	EQU	9
R10	EQU	10
R11	EQU	11
R12	EQU	12
R13	EQU	13
R14	EQU	14
R15	EQU	15
;
;---define some DXOP's - These are for this ROM Resident Monitor (TIMON) only
;
	DXOP	CALL,0		;SUBROUTINE CALL
	DXOP	RET,1		;SUBROUTINE RETURE
	DXOP	READ,2		;READ A CHARACTER
	DXOP	WRITE,3		;WRITE A CHARACTER
	DXOP	PUSHREG,4	;PUSHES R0-RX ONTO STACK	
	DXOP	POPREG,5	;POPS RX- R0 	
;
CR	EQU	0DH		;CARRIAGE RETURN
LF	EQU	0AH		;LINE FEED
;
	IF LOWRAM
WORKSP		EQU		0EFA0H	
XOPWP		EQU		0EFC0H	
INT3WP		EQU		0EFE0H	
	ENDI
	IF	HIRAM
WORKSP		EQU		0FA0H
XOPWP		EQU		0FC0H
INT3WP		EQU		0FE0H
	ENDI
;
CRUBASE 	EQU	80H
;
TIMON	AORG	0F000H
;
; WARM START ENTRY INTO TIMON
;
	JMP	START			;WARM START F002 IS COLD START 
;
; INITIALISATION
;
INITIAL	RSET					;CLEAR INTERRUPT MASK
	LWPI	WORKSP
	B	@INITIO				;SET UP IO AND BAUD RATE
;
;WARM START ENTRY POINT
;
START
	RSET					;DISABLE INTERRUPTS
	LWPI	WORKSP
	CLR	R0				;SET UP RESET AND INTERRUPT 3 VECTORS
	LI	R1,RESTAB
INITO	NOP					;WRITE ENABLE IF USING SINGLE STEP HARDWARE
	MOV	*R1+,*R0+
	CI	R0,3*4+4			;2 WORDS PER VECTOR
	JNE	INITO
	LI	R0,40H				;SET UP XOP0-XOP5 VECTORS
	LI	R1,XOPTAB
	LI	R2,XOPWP
INIT1	MOV	R2,*R0+
	NOP
	MOV	*R1+,*R0+
	CI	R0,58H
	JNE	INIT1
	CLR	R15			;LOW
	CLR	R14			;ADDRESS OF LAST OPEN CELL
	CLR	@2*R15+INT3WP		;CLEAR "USER PROGRAM" STATUS
	LI	R0,WORKSP-200H+60H	;INITIALISE STACK LIMIT
	MOV	R0,@2*R9+XOPWP
INIT2	MOV	@RESTAB,@2*R10+XOPWP	;INITIALISE STACK POINTER
;
BANNER	WRITE	@MESS00			;_PRINT ">> TMS9900 MONITOR <<"
;	WRITE	@MESS00
;	READ	R1			;READ ANY RUBBISH
PROMPT	WRITE	@MESS01			;PRINT PROMPTER
	BL	@HEXIN			;OBTAIN ADDRESS IN R2 AND INSTRUCTION IN R1
	LI	R4,19			;20 POSSIBLE INSTRUCTIONS
MON01	CB	@INTAB(R4),R1		;SEARCH INTAB
	JEQ	MON03
	DEC	R4
	JOC	MON01
MON02	WRITE	@MESS02			;PRINT " ??"
	JMP	PROMPT
MON03	SLA	R4,1					;BRANCH TO APPROPRIATEE ROUTINE
	MOV	@SUBTAB(R4),R4
	MOV	R3,R3					;TEST HEXIN FLAG
	B	*R4
;
; TABLES AND MESSAGES
;
RESTAB	WORD	WORKSP,INITIAL,0,0,0,0,INT3WP,INT3
XOPTAB	WORD	XOP0,XOP1,XOP2,XOP3,XOP4,XOP5
MESS00	TEXT	'> TMS9900 MONITOR V2.1 <'
	;	BYTE	0
MESS01	BYTE	CR,LF
		TEXT	'   >'
		BYTE	0
MESS02	TEXT	' ??'
		BYTE	0
MESS03	BYTE	LF,CR,LF
		TEXT	'     '
		BYTE	0
MESS04	TEXT	' STACK OVERFLOW AT'
		BYTE	0
ATHASH	BYTE	'@'
HASH	BYTE	'#',0
COMMA	BYTE	',',0
R		TEXT	'    '
RR		BYTE	'R',0
		EVEN
HEXTAB	TEXT	'0123456789ABCDEF'
NUMTAB	TEXT	'0 1 2 3 4 5 6 7 8 9 101112131415'
INTAB	BYTE	1AH			;CONTROL Z(CLEARS SCREEN)
	TEXT	'//QUGMZOWRPXLHST/. '
	EVEN
SUBTAB	WORD	BANNER,0,0,QBOOT,HEXLOAD,GO,MOVE,FIND,OUTPUT,WP,REGIST,PRINT
	WORD	XCUTE,LOWW,SETBP,STEP,TRACE,CHAR,INSTANT,OPEN
;

MASK32	WORD	001FH
MASK16	WORD	000FH
MASK8	WORD	0007H
MASK3	WORD	0003H
;
; XOP @XX,0 CALL @XX
;
; SUBROUTINE CALLING MECHANISM
;
XOP0	DECT	R10				;DECREMENT STACK POINTER
;	C	R10,R9				;CHECK FOR STACK OVERFLOW
;	JH	XOP0AA
;XOP0XXX	LWPI	WORKSP				;STACK OVERFLOW HANDLER
;	MOV	@2*14+XOPWP,R2
;	WRITE	@MESS04
;	BL	@HEXOUTX
;	B	@INIT2
XOP0AA	MOV	R14,*R10			;PUSH RETURN ADDRESS ON STACK
	MOV	R11,R14
	RTWP
;
; XOP1 - RET
;
; SUBROUTINE RETURN MECHANISM
;
XOP1	MOV	*R10+,R14
	RTWP
;
; XOP2
;
; TERMINAL INPUT (READ) EXTENDED OPERATION
;
XOP2	LI	R12,CRUBASE		;SET CRU BASE ADDRESS
XOP2AA	TB	21			;RECEIVE BUFFER REG. FULL?
	JNE	XOP2AA			;NO SO WAIT FOR RBRL = 1
	STCR	R0,8			;INPUT CHAR
	SBZ	18			;RESET RBRL
	MOVB	R0,*R11			;MOVE BYTE INTO EFFECTIVE ADDRESS
	RTWP
;
;--convert to upper case
;
TOUPPER	MOVB	*R11,R0
	SRL	R0,8
	CI	R0,61H
	JL	XOP2BB
	CI	R0,7AH
	JH	XOP2BB
	AI	R0,-20H
	SWPB	R0
	MOVB	R0,*R11
XOP2BB	RTWP
;
; XOP3 WRITE RX
;
; TERMINAL OUTPUT (WRITE) EXTENDED OPERATION
; USES R0
;
XOP3	LI	R12,CRUBASE		;SET CRU BASE ADDRESS
	SBO	16			;SET RTS ON
XOP3A	TB	22 			;TRANSMIT BUFFER REG. EMPTY?
	JNE	XOP3A			;NO, SO WAIT UNTIL IT IS
	MOVB	*R11,R0			;CONTINUE UNTIL BYTE 0 IS REACHED
	JEQ	XOP3B
	LDCR	*R11+,8
	JMP	XOP3A
XOP3B	SBZ	16			;RESET RTSON I.E. TURN OFF TRANSMITTER
	RTWP
;
; XOP4 - PUSHREG RX
;
; PUSHES R0-RX ONTO STACK		  
;
XOP4	MOV	R13,R1
XOP4AA	DECT	R10
;	C	R10,R9			;CHECK FOR STACK OVERFLOW
;	JLE	XOP0XXX
	MOV	*R1+,*R10
	C	R1,R11
	JLE	XOP4AA
	RTWP
;
; XOP5 - POPREG RX
;
; POPS RX-R0 OFF STACK
;
XOP5	MOV	*R10+,*R11
	DECT	R11
	C	R11,R13
	JHE	XOP5
	RTWP	 
;
; SUBROUTINE HEXIN
; INPUTS A HEX NO. INTO R2
; AND INSTRUCTION INTO R1
;
; USES R1,R2,R3,R4
;
HEXIN	CLR	R1
	CLR	R2
	SETO	R3			;SET FLAG
HEXIN0	READ	R1			;GET CHARACTER
	WRITE	R1			;PRINT CHARACTER
	LI	R4,15
HEXIN1	CB	@HEXTAB(R4),R1
	JNE	HEXIN2
	CLR	R3			;CLEARS FLAG
	SLA	R2,4			;SHIFTS HEX DIGIT INTO R2
	SOC	R4,R2
	JMP	HEXIN0
HEXIN2	DEC	R4
	JOC	HEXIN1
	MOV	R3,R3			;TEST HEXIN FLAG
	RT
;
; SUBROUTINE HEXOUT				;OUTPUT CONTENTS OF R2
; USES R0,R1,R2,R3
;
HEXOUT	WRITE	@MESS03+7			;PRINTS " "
HEXOUT0	PUSHREG	R3				;SAVE R0-R3
HEXOUTX	CLR	R0
	LI	R3,4
HEXOUT1	SRC	R2,12
	MOV	R2,R1
	ANDI	R1,000FH
	MOVB	@HEXTAB(R1),R0
	WRITE	R0
	DEC	R3
	JNE	HEXOUT1
	POPREG	R3				;RESTORE R3-R0
	RT
;
; INSTRUCTION ' '
;
OPEN	JNE	OPEN00				;JNE ON HEXIN FLAG
	MOV	R2,R14
OPEN00	ANDI	R14,0FFFEH			;MAKE ADDRESS EVEN
OPEN01	CALL	@PADDRC				;PRINT ADDRESS AND CONTENTS
	BL	@HEXIN
	JNE	OPEN02				;JNE ON HEXIN FLAG
	WREN
	MOV	R2,*R14
OPEN02	CI	R1,' '*256 			;LAST CHARACTER=" "?
	JNE	OPEN03
	INCT 	R14
	JMP	OPEN01
OPEN03	CI	R1,'-'*256 			;LAST CHARACTER="-"?
	JNE	MON00A
	DECT	R14
	JMP	OPEN01
MON00A	B	@PROMPT
;
; PRINT ADDRESS IN R14
;
PADDRC	WRITE	@MESS03+1			;PRINT INDENTATION
	MOV	R14,R2				;PRINT ADDRESS
	BL	@HEXOUT0
	MOV	*R14,R2				;PRINT CONTENTS OF ADDRESS
	BL	@HEXOUT
	WRITE	@MESS03+6			;PRINT "  "
	RET					;RETURN
;
; INSTRUCTION /
;
CHAR	JNE	CHAR00				;JNE ON HEXIN FLAG
	MOV	R2,R14
CHAR00	LI	R3,'/'*256 
CHAR01	MOV	R14,R4				;SET START ADDRESS
	CALL 	@PADDRC				;PRINT ADDRESS AND CONTENTS
	XOP	R3,3				;PRINT "/"
CHAR02	XOP	R1,2				;GET CHARACTER
	CI	R1,0800H			;BACKSPACE?
	JNE	CHAR03
	C	R4,R14
	JEQ	CHAR02
	XOP	R1,3				;PRINT BACKSPACE
	DEC	R14
	JMP	CHAR02
CHAR03	MOV	R1,R1				;IS CHARACTER CONTROL SHIFT &
	JEQ	CHAR04
	CI	R1,' '*256
	JL	MON00A			;RETURN TO MONITOR
CHAR04	WREN
	MOVB	R1,*R14+
	JNE	CHAR05
	LI	R1,'-'*256 		;UNDERSCORE
CHAR05	XOP	R1,3			;PRINT CHARACTER
	CZC	@MASK32,R14
	JNE	CHAR02
	XOP	R3,3			;PRINT "/"
	JMP	CHAR01
;
;
; INSTANT ASSEMBLER
;
; TABLES
;
TYPE1	TEXT	'SZC SZCBS   SB  C   CB  A   AB  '
	TEXT	'MOV MOVBSOC SOCB'
TYPE2	TEXT	'COC CZC XOR XOP LDCRSTCRMPY DIV '
TYPE3	TEXT	'BLWPB   X   CLR NEG INV INC INCT'
	TEXT	'DEC DECTBL  SWPBSETOABS ILL?ILL?'
TYPE4	TEXT	'JMP JLT JLE JEQ JHE JGE JNE JNC '
	TEXT	'JOC JNO JL  JH  JOP SBO SBZ TB  '
TYPE5	TEXT	'SRA SRL SLA SRC '
TYPE6	TEXT	'LI  AI  ANDIORI CI  '
TYPE7	TEXT	'STWPSTST'
TYPE8	TEXT	'LWPILIMI'
TYPE9	TEXT	'ILL?IDLERSETRTWPWRENCKOFLREX'
	EVEN
TYTAB	WORD	TYPE1,TYPE2,TYPE3,TYPE4,TYPE5
	WORD	TYPE6,TYPE7,TYPE8,TYPE9,TYTAB
TYSHIFT BYTE	10,8,4,6,6,3,3,3,3,0
	EVEN
TYBASE	WORD	4000H,2000H,0400H,1000H,0800H,0200H,02A0H,02E0H,0320H
TYSUB	WORD	T1,T2,T3,T4,T5,T6,T7,T8,T9
DOT	BYTE    '.',0
LOADERR	TEXT	'LOAD ERROR'
	BYTE	0
	EVEN
;
; GET MNEMONIC AND PLACE IN R8,R9
;
INSTANT	JNE	INST00					;JNE ON HEXIN FLAG
	MOV	R2,R14
INST00	STWP	R0
	AI	R0,2*8					;R0->R8
	LI	R8,'  '					;INITIALISE R8,R9
	MOV	R8,R9
	XOP	@PADDRC,0				;PRINT ADDRESS AND CONTENTS
	XOP	@DOT,3					;PRINT "."
	CLR	R2						;CHARACTER COUNT=0
INST01	XOP	R1,2					;GET CHARACTER
	XOP	R1,3					;PRINT CHARACTER
	CI	R1,'A'*256 				;IN ['A'..'Z'] ?
	JL	INST02
	CI	R1,'Z'*256
	JH	INST02
	MOVB	R1,*R0+
	INC	R2
	CI	R2,5					;GET AT MOST 5 CHARACTERS
	JNE	INST01
INST02	XOP	@MESS03+3(R2),3			;PRINT REMAINING SPACES
	CI	R1,' '*256 				;CHECK LAST CHARACTER
	JH	ERROR
	JL	INST10					;RETURN TO MONITOR
;
; SEARCH FOR MNEMONIC IN TABLE
;
	LI	R7,TYPE1
INST03	C	*R7,R8
	JNE	INST04
	C	@2(R7),R9
	JEQ	INST05
INST04	AI	R7,4
	CI	R7,TYTAB
	JNE	INST03
	JMP	ERROR
;
; FIND MNEMONIC TYPE AND CALCULATE BASIC OPCODE
;
INST05	CLR	R4						;R4:=OPTYPE
	LI	R3,TYTAB+2
INST06	C	R7,*R3+
	JL	INST07
	INC	R4
	JMP	INST06
INST07	S	@0-4(R3),R7
	MOVB	@TYSHIFT(R4),R0
	SRL	R0,8
	SLA	R7,0					;SHIFTS BY VALUE IN R0
	SLA	R4,1
	A	@TYBASE(R4),R7			;R7:=BASIC OPCODE
	CLR	R10						;NO OF WORDS IN INSTRUCTION
	MOV	@TYSUB(R4),R0
	B	*R0
;
T9		XOP		R1,2					;GET CHARACTER
INST08	XOP		R1,3					;PRINT LAST CHARACTER
		STWP	R0
		AI		R0,2*7					;R0->R7
INST09	WREN
		MOV		*R0+,*R14+
		DEC		R10
		JOC		INST09
		CI		R1,' '*256
		JH 		ERROR
		JEQ		INST00
INST10	B		@PROMPT					;RETURN TO MONITOR
;
DELIM	CI		R1,','*256 				;CHECK CH IN [' ',',']
		JEQ		DELIM00
		CI		R1,' '*256
		JH		ERROR
		JL		INST10
DELIM00	XOP		@COMMA,3				;PRINT ","
		RT
;
ERROR	XOP		@MESS02,3				;PRINT " ??"
		JMP		INST00
;
T1		BL		@SIX					;INSTRUCTION OF TYPE1
		BL		@DELIM
		A		R0,R7
		BL		@SIX
T100	SLA		R0,6
T101	A		R0,R7
		JMP		INST08
;
T2		BL		@SIX					;INSTRUCTION OF TYPE2
		BL		@DELIM
		A		R0,R7
		CI		R7,2C00H				;CHECK IF XOP,LDCR OR STCR
		JL		T200
		CI		R7,3400H
		JL		T201
T200	XOP		@RR,3					;PRINT "R"
T201	BL		@GETRC
		JMP		T100
;
T3		BL		@SIX					;;INSTRUCTION OF TYPE3
		A		R0,R7
		JMP		INST08
;
T4		XOP		@HASH,3					;INSTRUCTION OF TYPE4
		BL		@HEXIN
		JNE		INST08					;DEFAULT FOR JUMP INSTRUCTIONS
		CI		R7,1D00H				;IS INSTRUCTION SBO,SBZ,TB
		JHE		T400
		S		R14,R2					;CALCULATE JUMP OFFSET
		DECT	R2
		SRA		R2,1
		CI		R2,-128
		JLT		ERR1
		CI		R2,127
		JGT		ERR1
		ANDI	R2,0FFH
T400	CI		R2,0FFH
		JH		ERR1
		A		R2,R7
		JMP		INST08
;
T5		XOP		@RR,3					;INSTRUCTION OF TYPE5
		BL		@GETRC
		BL		@DELIM
		A		R0,R7
		BL		@GETRC
		SLA		R0,4
		JMP		T101
;
T6		XOP		@RR,3					;INSTRUCTION OF TYPE 6
		BL		@GETRC
		A		R0,R7
		BL		@DELIM
		JMP		T8
;
T7		XOP		@RR,3					;INSTRUCTION OF TYPE7
		BL		@GETRC
		JMP		T101
;
T8		XOP		@HASH,3					;_INSTRUCTION OF TYPE8
		BL		@HEXIN
		MOV		R2,R8
		INC		R10
		JMP		INST08
;
; GETRC	OBTAINS REGISTER NO OR CONSTANT NUMBER
;
GETRC	STWP	R6
		AI		R6,2*5			;R6->R5
		LI		R5,'  '
		LI		R2,3			;AT MOST 3 CHARACTERS
GETRC00 XOP		R1,2			;GET CHARACTER
		CI		R1,'0'*256 		;IN ['0'..'9'] ?
		JL		GETRC01
		CI		R1,'9'*256
		JH		GETRC01
		XOP		R1,3			;PRINT CHARACTER
		MOVB	R1,*R6+
		DEC		R2
		JNE		GETRC00
GETRC01	LI		R2,2*15
GETRC02	C		@NUMTAB(R2),R5		;TEST IF VALID NUMBER
		JEQ		GETRC03
		DECT	R2
		JOC		GETRC02
		JMP		ERR1
GETRC03	SRL		R2,1
		MOV		R2,R0			;R0:=HEX EQUIVALENT OF DECIMAL NUMBER
		RT
;
; SIX
;
SIX		MOV		R11,R12			;SAVE RETURN ADDRESS
		XOP		R1,2			;GET CHARACTER
		XOP		R1,3			;PRINT CHARACTER
		CI		R1,'R'*256 		;REGISTER ADDRESSING MODE
		JNE		SIX00
		BL		@GETRC
		B		*R12			;RETURN
SIX00	CI		R1,'*'*256			;INDIRECT ADDRESSING MODE
		JNE		SIX03
		XOP		@RR,3			;PRINT "R"
		BL		@GETRC
		AI		R0,10H			;AMODE:=1
		CI		R1,'+'*256 		;AUTO INCREMENT REGISTER MODE
		JNE		SIX02
		XOP		R1,3			;PRINT "+"
		AI		R0,20H			;AMODE:=3
		XOP		R1,2			;GET CHARACTER
SIX02	B		*R12			;RETURN
SIX03	CI		R1,'@'*256		;SYMBOLIC ADDRESSING MODE
		JNE		ERR1
		XOP		@HASH,3			;PRINT "#"
		BL		@HEXIN
		MOV		R10,R10			;TEST R10
		JNE		SIX04
		MOV		R2,R8
		JMP		SIX05
SIX04	MOV		R2,R9
SIX05	INC		R10
		CLR		R0
		CI		R1,'('*256		;INDEXED ADDRESSING MODE
		JNE		SIX07
		XOP		@RR,3			;PRINT "R"
		BL		@GETRC
		CI		R1,')'*256
		JEQ		SIX06
ERR1	B		@ERROR
SIX06	XOP		R1,3			;PRINT ")"
		XOP		R1,2			;GET CHARACTER
SIX07	AI		R0,20H			;AMODE:=2
		B		*R12
;
;
; INSTRUCTION H
;
SMESS0	BYTE	CR,LF,LF
		TEXT	'     BP '
		BYTE	0
SMESS1	TEXT	' SET AT'
		BYTE 	0
		EVEN
SETBP	LI		R5,INT3WP
		AI		R5,2*4			;R5->BP 1 (R4,R5,R6,R7)
		LI		R8,'1'*256
SETBP00 XOP		@SMESS0,3		;PRINT "     BP "
		XOP		R8,3			;PRINT BP NO.
		XOP		@SMESS1,3		;PRINT "SET AT"
		MOV		*R5+,R2			;PRINT CONTENTS
		BL		@HEXOUT
		XOP		@MESS03+6,3		;PRINT " "
		BL		@HEXIN			;GET NEW CONTENTS(IF REQUIRED)
		JNE		SETBP01			;JNE ON HEXIN FLAG
		MOV		R2,@0-2(R5)
SETBP01	CI		R1,' '*256
		JNE		SETBP02
		AI		R8,100H
		CI		R8,'5'*256
		JNE		SETBP00
SETBP02	B		@PROMPT
;
; INSTRUCTION T
;
TRACE 	LI		R4,20H
		MOV		R4,@2*9+INT3WP
		CLR		R4
		JMP		SETUP
;
; INSTRUCTION X
;
XCUTE	LI		R4,2
		JMP		SETUP
;
; INSTRUCTION S
;
STEP	LI		R4,4
;
SETUP	RSET					;DISABLE INTERRUPTS
		MOV		R4,@2*10+INT3WP
		MOV		R3,R3			;TEST HEXIN FLAG
		JNE		SETUP00
		MOV		R2,@2*14+INT3WP	;SET UP NEW START ADDRESS
SETUP00	LWPI	INT3WP			;CHANGE WORKSPACE
		MOV		R14,R12			;ADDRESS OF NEXT INSTRUCTION
		CZC		@MASK16,R15		;CHECK TO SEE IN R15 ALLOWS INTERRUPTS
		JNE		SETUP01
		AI		R15,3			;IF NOT ALLOW LEVEL 3 AND ABOVE
SETUP01	TRON					;TURN TRACE LOGIC ON
		RTWP					;RETURN TO PROGRAM BEING TRACED
;
; INTERRUPT 3 HANDLER
;
I3TAB	WORD	INT3AA,INT3CC,INT3GG	;TRACE,XCUTE,STEP
IMESS0	TEXT	'=>'
		BYTE	0
IMESS1	TEXT	'  WP='
		BYTE	0
IMESS2	BYTE	20H,20H			;CONTROL CHARACTERS TO POSITION CURSER
IMESS3	TEXT	'  ST='
		BYTE	0		
		EVEN
INT3	TROF				;RESETTRACE LOGIC
		MOV		@I3TAB(R10),R0		;JUMP TO APPROPRIATE HANDLER
		B		*R0
;
INT3AA	CZC		@MASK8,R9
		JNE		INT3BB
		XOP		@MESS03+1,3		;PRINT INDENTATION
INT3BB	MOV		R12,R2			;PRINT ADDRESS OF LAST INST.
		BL		@HEXOUT0
		XOP		@IMESS0,3		;PRINT "=>"
		DEC		R9
		JNE		INT3CC
		CLR		R1
		XOP		@MESS02+2,3		;PRINT "?"
		XOP		R1,2			;GET CHARACTER
		CI		R1,' '*256	
		JNE		INT3FF
		LI		R9,20H
;
; SEARCH BREAKPOINT TABLE
;
INT3CC	LI		R2,4
		STWP	R0
		AI		R0,2*4			;R0->BP 1
INT3DD	C		*R0+,R12		;IS INSTRUCTION BREAKPOINTED?
		JEQ		INT3EE
		DEC		R2
		JNE		INT3DD
		MOV		R14,R12			;R12:=ADDRESS OF NEXT INSTRUCTION
		TRON				;TURN TRACE LOGIC ON
		RTWP				;RETURN TO USER PROGRAM
;
INT3EE	XOP		@SMESS0,3		;PRINT INDENTATION+"   BP"
		XOP		@SMESS1+5,3		;PRINT "AT"
		MOV		R12,R2
		BL		@HEXOUT
		XOP		@IMESS1,3		;RINT "WP="
		MOV		R13,R2			;RINT USER WORKSPACE
		BL		@HEXOUT0
		XOP		@IMESS3,3		;RINT "ST="
		MOV		R15,R2			;RINT USER STATUS
		BL		@HEXOUT0
INT3FF	LWPI	WORKSP
		B		@PROMPT
;
INT3GG	XOP		R11,4			;SAVE	R0-R11
		XOP		@DISASM,0
		XOP		R11,5			;RESTORE R0-R11
		XOP		@IMESS2,3		;PRINT "ST="
		MOV		R15,R2			;PRINT STATUS
		BL		@HEXOUT0
		JMP		INT3FF			;RETURN TO MONITOR
;
; INSTRUCTION PRINT OUT REGISTERS
;
REGIST	LI	R4,2*13+INT3WP
	MOV	*R4,R4			;R4:=USER WORKSPACE BY DEFAULT
	MOV	R3,R3			;TEST HEXIN FLAG
	JNE	REGIST0
	MOV	R2,R4
REGIST0 ANDI	R4,0FFFEH		;MAKE ADDRESS EVEN	
	XOP	@MESS03,3		;PRINT INDENTATION
	XOP	@IMESS1+2,3		;PRINT "WP="
	MOV	R4,R2			;PRINT WORKSPACE ADDRESS
	BL	@HEXOUT0
	CLR	R5
	CLR	R10
REGIST1	LI	R9,0D0AH
	XOP	R9,3			;PRINT CR,LF
REGIST2	XOP	@R,3			;PRINT "R"
	MOV	@NUMTAB(R5),R9
	XOP	R9,3			;PRINT REGISTER NO
	LI	R9,' ='
	XOP	R9,3
	MOV	*R4+,R2			;PRINT REGISTER CONTENTS
	BL	@HEXOUT
	INCT	R5
	CI	R5,20H
	JEQ	MON00B
	CZC	@MASK3,R5
	JEQ	REGIST1
	JMP	REGIST2
;
; INSTRUCTION P
;
PRINT	MOV	R15,R12			;DEFAULT ACTION
	MOV		R3,R3			;TEST HEXIN FLAG
	JNE		PRINT00
	MOV		R2,R12
PRINT00	ANDI	R12,0FFFEH
		LI		R13,16			;INSTRUCTION COUNT
PRINT01	XOP		@DISASM,0		;CALL DISASSEMBLER
		DEC		R13			;DECREMENT INSTRUCTION COUNT
		JNE		PRINT01
		INC		R13
		XOP		R1,2			;GET CHARACTER
		LI		R13,8			;PRIME FOR 8 MORE LINES 
		CI		R1,' '*256 		;MORE INSTRUCTIONS TO BE DISASSEMBLED ?
		JEQ		PRINT01
MON00B	B	@PROMPT
;
; DISASSEMBLER
;
; TABLES
;
C0ATAB	WORD	CODE00,CODE00,CODE02,CODE02,CODE04,CODE04,CODE04,CODE04
		WORD	CODE08,CODE08,CODE08,CODE08,CODE00,CODE00,CODE00,CODE00
C2ATAB	WORD	DSIX,DSIX,DSIX,KSIX,KSIX,KSIX,DSIX,DSIX
C02ATAB WORD	IMMR,IMMR,IMMR,IMMR,IMMR,ONER,ONER,IMM
		WORD	IMM,DISASM2,DISASM2,DISASM2,DISASM2,DISASM2,DISASM2,DISASM2
;
DISASM	XOP		@MESS03+1,3		;PRINT INDENTATION
		MOV		R12,R2			;PRINT ADDRESS
		BL		@HEXOUT0
		MOV		*R12+,R5		;R5:=OPCODE
		MOV		R5,R2			;PRINT OPCODE
		BL		@HEXOUT
		MOV		R5,R6
		SRL		R6,12
		JNE		DISASM1
		MOV		R5,R6
		SRL		R6,7
		MOV		@C0ATAB(R6),R0
		B		*R0
DISASM1 CI	R6,3
	JH	CODE4
	CI	R6,2
	JHE	CODE2
;
	MOV	R5,R0
	ANDI	R0,0F00H
	SRL	R0,6
	AI	R0,TYPE4
	BL	@PMNEM
	MOV	R5,R2
	ANDI	R2,0FFH
	CI	R5,1D00H
	JHE	CODE100
	CI	R2,80H
	JL	CODE101
	ORI	R2,0FF00H
CODE101	SLA	R2,1
	A	R12,R2
CODE100 XOP	@HASH,3			;PRINT "#"
	BL	@HEXOUT0
DISASM2 XOP	R0,1			;RETURN
;
CODE2	MOV	R5,R6
	ANDI	R6,1C00H
	SRL	R6,8
	MOV	R6,R0
	AI	R0,TYPE2
	BL	@PMNEM
	SRL	R6,1
	MOV	@C2ATAB(R6,R0
	B	*R0
;
CODE4	SLA	R6,2
	MOV	R6,R0
	AI	R0,TYPE1-16
	BL	@PMNEM
	XOP	@SIXBITS,0
	XOP	@COMMA,3		;PRINT ","
	XOP	@SIXBITD,0
	XOP	R0,1			;RETURN
;
CODE00	LI	R0,TYPE9
	BL	@PMNEM
	XOP	R0,1			;RETURN
;
CODE02	MOV	R5,R6
	ANDI	R6,01E0H
	SRL	R6,3
	MOV	R6,R0
	AI	R0,TYPE6
	BL	@PMNEM
	SRL	R6,1
	MOV	@C02ATAB(R6),R0
	B	*R0
;
CODE04	MOV	R5,R0
	ANDI	R0,03C0H
	SRL	R0,4
	AI	R0,TYPE3
	BL	@PMNEM	
	CI	R5,07C0H
	JHE	CODE040
	XOP	@SIXBITS,0
CODE040 XOP	R0,1			;RETURN
;
CODE08	MOV	R5,R0
	ANDI	R0,0300H
	SRL	R0,6
	AI	R0,TYPE5
	BL	@PMNEM
	MOV	R5,R6
	XOP	@REG,0
	XOP	@COMMA,3		;PRINT ","
	SRL	R5,3
CFIELD  ANDI	R5,1FH			;PRINTS CONSTANT FIELD
	MOV	@NUMTAB(R5),R9
	XOP	R9,3
	XOP	R0,1			;RETURN
;
DSIX	XOP	@SIXBITS,0		;PRINTS SIXBIT FIELD + REGISTER
	XOP	@COMMA,3		;PRINT ","
	MOV	R5,R6
	SRL	R6,6
	XOP	@REG,0
	XOP	R0,1			;RETURN
;
KSIX	XOP	@SIXBITS,0		;PRINTS SIXBIT FIELD + CONSTANT
	XOP	@COMMA,3		;PRINT ","
	SRL	R5,5
	JMP	CFIELD
;
;
;
IMMR	MOV	R5,R6			;PRINTS REGISTER NO. + IMMEDIATE OPERAND
	XOP	@REG,0
	XOP	@COMMA,3		;PRINT ","
IMM	XOP	@HASH,3			;PRINT "#"
	MOV	*R12+,R2
	BL	@HEXOUT0
	XOP	R0,1			;RETURN
;
ONER	MOV	R5,R6			;PRINTS REGISTER
	XOP	@REG,0
	XOP	R0,1			;RETURN
;
REG	ANDI	R6,0FH		;PRINTS REGISTER NO. E.G. R1,R10
	SLA	R6,1
	XOP	@RR,3			;PRINT "R"
	MOV	@NUMTAB(R6),R9
	CI	R6,14H
	JHE	REG00
	ANDI	R9,0FF00H
REG00	XOP	R9,3
	XOP	R0,1			;RETURN
;
SIXBITS	MOV	R5,R6			;DECODES AND PRINTS SIXBIT SOURCE FIELD
	JMP	SIXBIT
SIXBITD	MOV	R5,R6			;DECODES AND PRINTS SIXBIT DEST. FIELD
	SRL	R6,6
SIXBIT	ANDI	R6,3FH			;R6:=SIXBIT FIELD
	MOV	R6,R7			
	ANDI	R6,0FH			;R6:=REGISTER
	SRL	R7,4			;R7:=ADDRESSING MODE
	JNE	SIXBIT0
	XOP	@REG,0			;REGISTER ADDRESSING MODE
	JMP	SIXBIT3
SIXBIT0	CI	R7,2			;SYMBOLIC ADDRESSING MODE
	JNE	SIXBIT2
	XOP	@ATHASH,3		;PRINT "@#"
	MOV	*R12+,R2		
	BL	@HEXOUT0
	CI	R6,0			;INDEXED ADDRESSING MODE
	JEQ	SIXBIT3
	LI	R1,'('*256 		;PRINT "("
	XOP	R1,3
	XOP 	@REG,0
	LI	R1,')'*256
	XOP	R1,3			;PRINT ")"
	JMP	SIXBIT3
SIXBIT2 LI	R1,'*'*256		;INDIRECT REGISTER ADDRESSING MODE
	XOP	R1,3
	XOP	@REG,0
	CI	R7,3
	JNE	SIXBIT3
	LI	R1,'+'*256 		;AUTO INCREMENT ADDRESSING MODEBT
	XOP	R1,3
SIXBIT3	XOP	R0,1			;RETURN
;
PMNEM	XOP	@MESS03+6,3		;SUBROUTINE TO PRINT OPCODE MNEMONIC
	CLR	R10
	MOV	*R0+,R8
	MOV	*R0,R9
	XOP	R8,3
	XOP	@MESS03+7,3		;PRINT " "
	RT
;
; INSTRUCTION M
;
MMESS0	TEXT	'OVE BYTES '
	BYTE	0
MMESS1	TEXT	'TO '
	BYTE	0
MMESS2	TEXT	'YES OR NO? '
	BYTE	0
	EVEN
MOVE	XOP	@MMESS0,3		;PRINT "OVE BYTES "
	BL	@HEXIN
	JNE	MOVE04			;JNE ON HEXIN FLAG
	MOV	R2,R8			;R8:=LOW ADDRESS
	CI	R1,':'*256
	JNE	MOVE04			;ERROR
	BL	@HEXIN
	JNE	MOVE04			;JNE ON HEXIN FLAG
	C	R8,R2
	JH	MOVE04
	MOV	R2,R7			;R7:=HIGH ADDRESS
	XOP	@MMESS1,3		;PRINT " TO"
	BL	@HEXIN
	JNE	MOVE04			;JNE ON HEXIN FLAG
	MOV	R2,R6			
	XOP	@MESS03,3		;PRINT INDENTATION
	XOP	@MMESS2,3		;PRINT "YES OR NO?"
	XOP	R1,2			;GET CHARACTER
	XOP	R1,3			;PRINT CHARACTER
	CI	R1,'Y'*256
	JNE	MON00C			;RETURN TO MONITOR
	C	R6,R8
	JEQ	MON00C			;LOW=DESTINATION
	JH	MOVE01
MOVE00	MOVB	*R8+,*R6+		
	C	R8,R7
	JH	MON00C			;RETURN TO MONITOR
	JMP	MOVE00
MOVE01	C	R6,R7
	JH	MOVE00
	S	R8,R6
	A	R7,R6
MOVE02	MOVB	*R7,*R6
	DEC	R7
	DEC	R6
	C	R7,R8
	JHE	MOVE02
MON00C	B	@PROMPT
MOVE04	B	@MON02			;PRINTS " ??"
;
; INSTRUCTION Z
;
FMESS00	TEXT	'NOT FOUND'
	BYTE	0
	EVEN
FIND	MOV	R15,R9
	MOV	R2,R7
FIND00	CB	*R9+,R7
	JNE	FIND01
	SWPB	R7
	CB	*R9,R7
	SWPB	R7
	JEQ	FIND02
FIND01	C	R9,R15
	JNE	FIND00
	XOP	@MESS03,3		;PRINT INDENTATION
	XOP	@FMESS00,3		;PRINT "NOT FOUND"
	JMP	MON00C
FIND02	XOP	@MESS03,3		;PRINT INDENTATION
	MOV	R9,R2
	DEC	R2
	BL	@HEXOUT0		;PRINT ADDRESS
	MOV	R7,R2
	BL	@HEXOUT			;PRINT CONTENTS
	XOP	@MESS03+6,3		;PRINT "  "
	BL	@HEXIN
	JNE	FIND03			;JNE ON HEXIN FLAG
	WREN
	MOVB	R2,@0FFFFH(R9)
	SWPB	R2
	WREN
	MOVB	R2,*R9
FIND03	CI	R1,' '*256
	JEQ	FIND01
	JMP	MON00C
;
; INSTRUCTION G
;
GO	JNE	MON00C				;JNE ON HEXIN FLAG
	B	*R2
;
; INSTRUCTION L
;
LMESS0	TEXT	'Low='
	BYTE	0
	EVEN
LOWW	JNE	LOW00				;JNE ON HEXIN FLAG
	MOV	R2,R15
	JMP	MON00C
LOW00	XOP	@MESS03,3			;PRINT INDENTATION
	XOP	@LMESS0,3			;PRINT "LOW="
	MOV	R15,R2				;PRINT USER WORKSPACE
	BL	@HEXOUT0
	JMP	MON00C
;
; INSTRUCTION W
;
WP	JNE	WP00				;JNE ON HEXIN FLAG
	MOV	R2,@2*R13+INT3WP
	JMP	MON00C
WP00	XOP	@MESS03,3			;PRINT INDENTATION
	XOP	@IMESS1+2,3			;PRINT "WP="
	MOV	@2*R13+INT3WP,R2
	BL	@HEXOUT0
	JMP	MON00C
;
; INSTRUCTION O
;
OUTPUT	MOV	R15,R4
	MOV	R3,R3
	JNE	OUTPUT0
	MOV	R2,R4
OUTPUT0 ANDI	R4,0FFFEH		;MAKE ADDRESS EVEN
	MOV	R4,R5
	ANDI	R5,0FFF0H
	AI	R5,80H
OUTPUT1	XOP	@MESS03+1,3		;PRINT INDENTATION
	MOV	R4,R2
	BL	@HEXOUT0		;PRINT ADDRESS
	XOP	@MESS03+7,3		;PRINT " "
OUTPUT2 MOV	*R4+,R2
	BL	@HEXOUT
	C	R4,R5
	JEQ	OUTPUT3
	CZC	@MASK16,R4
	JEQ	OUTPUT1
	JMP	OUTPUT2
OUTPUT3	XOP	R1,2			;GET CHARACTER
	CI	R1,' '*256
	JNE	MON00C
	AI	R5,80H			;AN EXTRA 4 LINES
	JMP	OUTPUT1

;
;	LOAD HEX FILE 
;
;	ALGORITHM TAKEN FROM DDJ #22
;
;	R3  HOLDS CHECKSUM
;	R4  HOLDS RECORD LENGTH
;	R5  HOLDS LOAD ADDRESS	
;
;

;
	EVEN
;
HEXLOAD LI	R2,':'*256
	READ	R1		;SEARCH FOR ':'
	CB	R1,R2		;COMPARE BYTE FOR :
	JNE	HEXLOAD
	WRITE	@DOT		;DEBUG INFO
	CLR 	R3		;CLEAR CHECKSUM
	CALL	@NEXTBYTE	;GET RECORD LENGTH
	MOVB	R1,R4
	SRL	R4,8		;LENGTH IN R4
	JEQ	A16		;WERE DONE
	CALL	@NEXTADDR	;GET LOAD ADDRESS
	MOV	R1,R5
	CALL	@NEXTBYTE	;GET RECORD TYPE
A7	MOV	R4,R4		;IF RL=0 GO TO A13
	JEQ	A13
	CALL	@NEXTBYTE
	MOVB	R1,*R5+		;STORE DATA IN MEMORY
	DEC	R4		;REDUCE RECORD LENGTH
	JMP	A7
A13	CALL	@NEXTBYTE	;GET CHECKSUM BYTE 
	MOVB	R3,R3		;CHECK FOR ZERO
	JEQ	HEXLOAD
;
; FALL THROUGH TO ERROR
;
	WRITE	@LOADERR		;TELL TERMINAL SYSTEM TO STOP
A16	B	@PROMPT			;BACK TO TIMON
;
NEXTBYTE 
	CLR 	R2			;ACCUMULATOR
	READ	R1			
	CALL	@CATOH			;CONVERT ASCII TO HEX
	MOVB	R1,R2
	SLA	R2,4			;MOVE IT OVER
	READ	R1			;NEXT ASCII CHAR
	CALL	@CATOH
	SOCB	R1,R2			;BYTE NOW IN R1
	MOV	R2,R1
	AB	R1,R3			;UPDATE CHECKSUM
	RET
;
NEXTADDR 
	CALL	@NEXTBYTE
	MOV	R1,R5
	CALL	@NEXTBYTE
	SWPB	R1
	SOC	R5,R1
	RET
;
;	ASCII TO HEX CONVERTER
;
CATOH	CI	R1,'9'*256
	JLE	GOTONE
	AI	R1,0900H		;ALPHA ADJUST
GOTONE	ANDI	R1,0F00H
	RET
;
;---ATTEMPT A COLD BOOT
;
MONITOR EQU	0E600H
BOOT	EQU	MONITOR+12*4		;PERFORM A COLD BOOT

QBOOT	BLWP	@MONITOR		;NEED TO SET UP MONITOR
	B	@BOOT			;BRANCH HERE TO LOAD THE SYSTEM
;
;---INITIALISE TMS9902 FOR : 	*BAUD RATE
;				*8 BITS/CHARACTER
;				*NO PARITY
;				*2 STOP BITS
;
INITIO	LI	R12,CRUBASE
	SBO	31				;RESET TMS9902
	LDCR	@CTL02,8
	SBZ	13				;DO NOT SET INTERVAL REGISTER
	CLR	R3				;RESET LOOP COUNT
TSTSP	TB	15				;SPACE
	JEQ	TSTSP				;NO JUMP BACK
SPLOOP	INC	R3				;TIME THE START BIT
	TB	15				;FALL OUT ON MARK
	JNE	SPLOOP
;
;---TABLE SEARCH FOR BAUD RATES
;	SET AT 19200
;
	LI	R7,BD19200		;SET POINTER TO TABLE
	LI	R7,BD9600		;SET POINTER TO TABLE
	INCT	R7
	JMP	BDMATCH			;FORCE THE BAUD RATE TO BE 19200
;
;	NOT USED
;
BDLOOP	C	R3,*R7+			;DO WE HAVE A MATCH ?
	JLE	BDMATCH			;YES , SET BAUD RATE
	INCT	R7			;NO UPDATE POINTER
	JMP	BDLOOP

;
; LOAD THE BAUD RATE VALUES
;	
BDMATCH LDCR	*R7,12 			;INT RECV/TXMT DATA RATE 
	LDCR	*R7,11 
	STCR	R7,8			;PULL OUT ANY JUNK
	STCR	R7,8
	B	@START
;	
CTL02	BYTE	43H			;43H FOR A 3 MHZ CLOCK 4B FOR A 4 MHZ CLOCK
	EVEN
BD19200 WORD	9,1AH			;BAUD RATE = 19200
BD9600	WORD 	19,34H			;BAUD RATE = 9600
	WORD	39,68H			;BAUD RATE = 4800
	WORD	79,0D0H			;BAUD RATE = 2400
	WORD	156,1A0H		;BAUD RATE = 1200
	WORD	312,340H		;BAUD RATE = 600
	WORD	776,4D0H		;BAUD RATE = 300
;
;
;---Place load vectors into FFFC & FFFE
;
	AORG	0FFFCH
	WORD	WORKSP
	WORD	INITIAL
;
	END

