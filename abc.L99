                        ;       Math48 Floating Point Package
                        ;       Version 1.1 Revision 1
                        ;       by Anders Hejlsberg
                        ;       2532 Bytes
                        ;       TMS9900/99000 VERSION BY ALEXANDER CAMERON JUNE 2020
                        ;		PARTS TAKEN FROM CFLOAT.C AS PART OF SMALLCPLUS
                        ;
                        ;
                        ;
                        ;Floating number format.
                        ;   ============================================================
                        ;
                        ;     A floating number is made by the three 16-bit registers BC, DE and HL
                        ;     (collectively called AC) or the corresponding alternative registers
                        ;     BC', DE' og HL' (collectively called AC').;
                        ;
                        ;     The five 8-bit registers B,C,D,E and H (Collectively called BCDEH) represent
                        ;     in the mentioned succession the number mantissa in binary representation.
                        ;     The binary decimal point is placed immediately in front of the B register.
                        ;     In this way, the bit 7 of B tell the number of halves (2^-1) in the number,
                        ;     bit 6 the number of quarters (2^-2) etc.
                        ;     The value of the mantissa may also be aprehended as the binary integer
                        ;     BCDEH divided by 2^40.;
                        ;
                        ;     The L register contain the number exponent, that is the number 2 must be
                        ;     raised to, to give the factor that the mantissa shall be multiplied by.
                        ;     The absolute value of the L register is the exponent plus
                        ;     128 (80H). If for example L has the value 83H the exponent will be 3.
                        ;     If L has the value 7DH the exponent is -3.
                        ;     If L is zero it tells that the whole number is zero. In this way the
                        ;     exponent may take any integer value between -127 (01H) and 127 (FFH).
                        ;
                        ;     Of this it is seen that the number in AC shall be comprehended in the
                        ;     following way.;
                        ;
                        ;         AC=(BCDEH/2^40)*2^(L-128)
                        ;
                        ;     Where BCDEH is a whole binary number.
                        ;
                        ;     As the exponent is the power that 2 shall be raised to, then it is given,
                        ;     that the value of AC is doubled if one is added to the exponent, and
                        ;     halved if one is subtracted from the exponent.
                        ;     Likewise it is given that the number in BCDEH is doubled if it is shifted
                        ;     one bit to the left and halved if it is shifted one bit to the right.
                        ;     One may therefore, theoretically speaking, shift BCDEH to right or
                        ;     left an arbitrary number of bits, as long as this number is added or
                        ;     subtracted from the exponent.
                        ;
                        ;     The above stated is exploited in every calculation to normalize
                        ;     the number in AC:
                        ;     The mantissa (BCDEH) is repeatedly shifted one bit left untill the
                        ;     most significant bit is set (bit 7 in B). Hereafter the number of shifts are
                        ;     subtracted from the exponent.
                        
                        ;     This normalizing is done for two reasons: firstly is is
                        ;     securing that the number has the maximum precision, as it
                        ;     leaves the most significant bits in the mantissa.
                        ;     Secondly it releases the most significant bit of the mantissa,
                        ;     as this bit will always be set in a normalized number. The most
                        ;     significant bit is in stead used as a sign indicator:
                        ;     If it is set then the number is negative. If it is zero then the number
                        ;     is positive. The absolute value of a number may thus be calculated
                        ;     by simply resetting the bit 7 in the B register.
                        ;
                        ;     The construction of a floating number is compiled to:
                        ;
                        ;         Reg. Bit    Meaning;
                        ;
                        ;          B    7     Sign. 0=Positive. 1=Negative.
                        ;          B   6-0    mantissa bit   38-32. Bit 39 always set.
                        ;          C   7-0    mantissa bit   31-24.
                        ;          D   7-0    mantissa bit   23-16.
                        ;          E   7-0    hantisse bit   15-8.
                        ;          H   7-0    hantisse bit   7-0.
                        ;          L   7-0    L=0: the number is Zero.
                        ;                     L>0: Exponent+128 (80H).;
                        ;
                        ;     If a floating point number is zero (ie. if the L register is zero)
                        ;     then it does'nt matter what is in the mantissa as long as the sign
                        ;     bit is zero.
                        ;
                        ;     Examples of floating point numbers (BCDEH and L in hexnotation):;
                        ;
                        ;      BCDEH       L   Value             Remarks;
                        ;
                        ;      0000000000  00  0                 L er nul.
                        ;      0000000000  81  1                 2^-1*2^1.
                        ;      0000000000  82  2                 2^-1*2^2.
                        ;      8000000000  82  -2                Negative as bit 7 in B is set.
                        ;      7000000000  84  15                (2^-1+2^-2+2^-3+2^-4)*2^4.
                        ;      4800000000  87  100               (2^-1+2^-2+2^-5)*2^7.
                        ;      4CCCCCCCCD  7D  0.1               Not final
                        ;      0000000000  01  2.938735877E-39   Smallest possible number.
                        ;      7FFFFFFFFF  FF  1.701411835E+38   Largest possible number.
                        ;     ===================================================================
                        ;
                        ;
                        ;     For the 9900 construction of a floating number is compiled to:
                        ;
                        ;         Reg. Bit    Meaning;
                        ;
                        ;       R5 MSB 7      Sign. 0=Positive. 1=Negative.
                        ;       R5 MSB 6-0    mantissa bit   38-32. Bit 39 always set.
                        ;       R5 LSB 7-0    mantissa bit   31-24.
                        ;       R6 MSB 7-0    mantissa bit   23-16.
                        ;       R6 LSB 7-0    mantisse bit   15-8.
                        ;       R7 MSB 7-0    mantisse bit   7-0.
                        ;       R7 LSB 7-0    L=0: the number is Zero.
                        ;					  L>0: Exponent+128 (80H).;
                        ;
                        
  0000                  R0			EQU 	0
  0001                  R1			EQU 	1		; Can be used but in some operations they are AC' prime registers
  0002                  R2			EQU 	2		; Can be used but in some operations they are AC' prime registers
  0003                  R3			EQU 	3		; Can be used but in some operations they are AC' prime registers
  0004                  R4			EQU 	4
  0005                  R5			EQU 	5
  0006                  R6			EQU 	6
  0007                  R7			EQU 	7
  0001                  R5'			EQU		R1		;Prime register
  0002                  R6'			EQU		R2		;Prime register
  0003                  R7'			EQU		R3		;Prime register
  000D                  WP			EQU 	13		;WORKSAPCE REGISTER
  000F                  ST			EQU		15		;STATUS REGISTER
  000A                  SP			EQU 	10		;STACK POINTER
  000B                  R11			EQU 	11
                        
                        			DXOP 	CALL,6
                        			DXOP 	RET,7
                        			DXOP 	PUSH,8
                        			DXOP 	POP,9
                        			DXOP	WHEX,10
                        
  0080                  SIGN:   	EQU  	80H
  0080                  EXPN:   	EQU  	80H
                        
  00F0                  IWIDTH: 	EQU  	0F0H
  000F                  FWIDTH: 	EQU  	0FH
                        
  0000                  EXTRA:		BSS		6
                        
                        ;
                        ; This storage is used to store the stack variables etc that small-C calls
                        ; to load and store the packed floating point numbers.
                        ; Actual manipulation and arithmatic is done using R5,R6, and R7 agains R5', R6' and R7'
                        ;
                        FPA:
  0006                  			BSS		2		;R5
  0008                  			BSS		2		;R6
  000A                  			BSS		2		;R7
                        
  000C                  DSIGN:		BSS		1		;msb indicates sign of FA, 0 is negative, 1 is positive
  000D   00             			EVEN
  000E   2DA0 0046      DIVZERO: 	CALL	@GRIPE
  0012   6361 6E27      			TEXT	"can't"
  0016   74             
  0017   00             			BYTE	0
  0018                  			EVEN
  0018   2DA0 0046      ILLFCT:		CALL	@GRIPE
  001C   496C 6C65      			TEXT	"Illegal function"
  0020   6761 6C20      
  0024   6675 6E63      
  0028   7469 6F6E      
  002C   00             			BYTE	0
  002D   00             			EVEN
  002E   2DA0 0046      OFLOW:		CALL	@GRIPE
  0032   4172 6974      			TEXT	"Arithmetic overflow"
  0036   686D 6574      
  003A   6963 206F      
  003E   7665 7266      
  0042   6C6F 77        
  0045   00             			BYTE	0
  0046                  			EVEN
                        GRIPE:		;CALL	@QERR			;top word on stack points to message
  0046   0460 F000      			B		@0f000H  		;SHELL this a temporary hack - how do we handle fatal error
  004A                  			EVEN
                        
                        ;
                        ;  To do
                        ;
                        _fpdiv::
                        _fpmul::
                        _fpswap::
                        
  004A   2DC0           		RET
                        
                        ;
                        ; LOAD FPN AT ADDRESS IN R4 INTO ACCUMULATOR
                        ;
  004C   0200 0006      _fload::	LI		R0,FPA
  0050   CC34           			MOV	 	*R4+,*R0+	;R5
  0052   CC34           			MOV	 	*R4+,*R0+	;R6
  0054   C414           			MOV 	*R4,*R0		;R7
  0056   2DC0           			RET
                        
                        ;
                        ;	STORE FROM FPA TO THE ADDRESS IN R4
                        ;
  0058   0200 0006      _fstore::	LI		R0,FPA
  005C   CD30           			MOV		*R0+,*R4+	;R5
  005E   CD30           			MOV		*R0+,*R4+	;R6
  0060   C510           			MOV		*R0,*R4		;R7
  0062   2DC0           			RET
                        ;
                        ;	load FPA from (R4) and push FA (fall through to _fpush
                        ;
                        _fldpsh::
  0064   0200 0006      			LI		R0,FPA
  0068   CC34           			MOV		*R4+,*R0+	;R5
  006A   CC34           			MOV		*R4+,*R0+	;R6
  006C   C414           			MOV		*R4,*R0		;R7
                        ;
                        ;	push the floating point accumulator
                        ;	(preserving return address)
                        ;
  006E   0201 0001      _fpush::	LI		R1,R5'		;POINT TO R5
  0072   2E44           			POP		R4			;GRAB RETURN ADDRESS
  0074   064A           			DECT	SP
  0076   C6B1           			MOV 	*R1+,*SP	;PUSH R5
  0078   064A           			DECT	SP
  007A   C6B1           			MOV 	*R1+,*SP	;PUSH R6
  007C   064A           			DECT	SP
  007E   C691           			MOV 	*R1,*SP		;PUSH R7
  0080   2E04           			PUSH	R4			;PUSH RETURN ADDRESS AND THEN RETURN
  0082   2DC0           			RET
                        ;
                        ;	push floating point accumulator
                        ;	(preserve return address and next stacked word)
                        ;
                        ;
  0084   2E44           _fpush2:: 	POP		R4			;GRAB RETURN ADDRESS
  0086   2E42           			POP		R2			;SAVE THE NEXT WORD
  0088   0201 0006      			LI		R1,FPA
  008C   064A           			DECT	SP
  008E   C6B1           			MOV 	*R1+,*SP	;R5
  0090   064A           			DECT	SP
  0092   C6B1           			MOV 	*R1+,*SP	;R6
  0094   064A           			DECT	SP
  0096   C691           			MOV 	*R1,*SP		;R7
  0098   2E02           			PUSH	R2			;PUSH BACK THE ORIGINAL WORD
  009A   2E04           			PUSH	R4			;PUSH RETURN ADDRESS AND THEN RETURN
  009C   2DC0           			RET
                        
                        ;			COULD DO IT THIS WAY TO AVOID PUSHS AND POPS
                        
  009E   CA9A FFFC      			MOV		*SP,@-4(SP)
  00A2   CAAA 0002      			MOV		@2(SP),@-2(SP)
  00A6   FFFE           
  00A8   C6A0 0008      			MOV 	@FPA+2,*SP
  00AC   CAA0 0006      			MOV 	@FPA,@2(SP)
  00B0   0002           
  00B2   064A           			DECT	SP
  00B4   064A           			DECT 	SP				;SP NOW POINTS TO RETURN ADDRESS
  00B6   2DC0           			RET
                        
                        ;
                        ;FLOATING POINT ADDITION.
                        ;
                        ; Add R5, R6 and R7 to floating point accumulator
                        ; In aligning the comments of Math48 AC' will be the FPA and
                        ; AC will be R5, R6 and R7
                        ; AC' is equivalent to R5',R6' and R7'
                        ;
                        ; Left Sign | 	Right Sign | Left Mant > Right Man| COmpute As |  Result Is
                        ;
                        ;	    -			+			Yes					LM - RM			-
                        ;		+			-			Yes					LM - RM			+
                        ;		-			+			No					RM - LM			+
                        ;		+			-			No					RM - LM			-
                        ;
                        ;
  00B8   2E44           _fpadd::  	POP		R4				;save return address
  00BA   2E47           			POP		R7
  00BC   2E46           			POP		R6
  00BE   2E45           			POP		R5
  00C0   2E04           			PUSH	R4				;replace return address
  00C2   02AD           			STWP	WP				;Need to offset into wp
                        
  00C4   0C09 01C5      	       	TMB		R5,7			;Is AC negative?
  00C8   1602                      	JNE		ADD1
  00CA   0460 029C                 	B		@SUB1    		;Yes => SUB1
                        
  00CE   0201 0004      ADD1:   	LI		R1,R7'+1 		;Is AC' zero?
  00D2   D041                   	MOVB	R1,R1
  00D4   1601                   	JNE		ADD1A	  		;No
  00D6   2DC0                  		RET  		      		;Yes => Return
                        
  00D8   D02D 000F      ADD1A:      MOVB	@2*R7+1(WP),R0	;Is AC zero?
  00DC   1607                   	JNE		ADD2    		;No => ADD2
  00DE   D020 0002              	MOVB	@R5'+1,R0
  00E2   0C0B 01C0               	TSMB	R0,7			;Set AC' Positive - why?
  00E6   D800 0002               	MOVB	R0,@R5'+1
  00EA   104D                   	JMP   	ADD10
                        
  00EC   0C0B 01C5      ADD2:   	TSMB	R5,7			;Set sign bit of MSB of AC
  00F0   D045           			MOVB	R5,R1			;Save it for next operation
  00F2   D020 0001               	MOVB	@R5',R0
  00F6   0C0B 01C0               	TSMB	R0,7       		;Set MSB'
  00FA   D800 0001               	MOVB	R0,@R5'
                        
  00FE   7040                   	SB		R0,R1	        ;R1 - R0 => EXP'-EXP
  0100   1311                   	JEQ		ADD4     		;EXP=EXP' => ADD4
  0102   1503                   	JGT		ADD2A    		;EXP<EXP' => ADD3
                        ;
                        ;		Negative difference so we have to make positive
                        ;
  0104   04C0                   	CLR		R0         		;Make R1 positive
  0106   7001                   	SB		R1,R0			;0 - R1
  0108   D040                   	MOVB	R0,R1
  010A   0981           ADD2A:     	SRL		R1,8			;Move difference into LSB and zero MSB
  010C   0601           			DEC		R1
  010E   C087           			MOV		R7,R2			;Can't increment R7 without affecting higher order bits
  0110   0242 00FF      			ANDI	R2,0FFH			;R2 Holds value of exponent
                          ;
                          ;			R1 HOLDS THE DIFFERENCE OR ADJUSTMENT NEEDED
                          ;
                        
  0114   2DA0 0318      ADD3:   	CALL 	@SRIGHT     		;Shift right by 1 position
  0118   0582           			INC		R2				;Increment MSB - is
  011A   0601                   	DEC  	R1         		;Is  EXP=EXP'?
  011C   16FB                     	JNE	 	ADD3    		;No => ADD3
  011E   0247 FF00                	ANDI	R7,0FF00H		;Need to update R7
  0122   E1C2                     	SOC		R2,R7			;Update R7 exponent by OR-ing together
                                  							;This assumes that MSB of R3 is zero
                        
  0124   0C09 01C5      ADD4:   	TMB		R5,7			;Get the AC sign
  0128   130E            			JEQ		ADD5    		;If it is negative => ADD5
                        
  012A   2DA0 0196              	CALL 	@ADDAC      		;MANT=MANT+MANT'
  012E   1726                   	JNC		ADD9    		;No overflow then => ADD9
                        ;
                        ; There has been an overflow so we need to rotate the mantissa to the right 1 place
                        ;
  0130   2DA0 0318              	CALL 	@RIGHT      		;Rotate to the right
  0134   C087                   	MOV		R7,R2			;Can't increment R7 without affecting higher order bits
  0136   06C2            			SWPB	R2
  0138   0200 0100              	LI		R0,256
  013C   B040             			AB		R0,R1			;Add 1 (signed to the value of the exponent)
  013E   DB41 000F      	        MOVB	R1,@2*R7+1(WP)	;Update R7 exponent
  0142   161C           	        JNE		ADD9
                        	        ;;;SET CARRY FLAG indicating error - maybe use R4 = 0
  0144   1020           	        JMP		ADD10
                        
  0146   2DA0 01CC      ADD5:   	CALL 	@CMPAC      		;Compare
  014A   02C4           			STST	R4				;Save the status register
  014C   1314                   	JEQ		ADDZ     		;AC=AC' => ADDZ
  014E   1702                   	JNC		ADD6     		;AC>AC' => ADD6
  0150   2DA0 03B4      			CALL	@EXX			;Exchange
  0154   2DA0 01B2      ADD6:   	CALL 	@SUBAC      		;MANT=MANT-MANT'
  0158   0C09 01C5      ADD7:   	TMB		R5,7       		;normalised?
  015C   160E                   	JNE		ADD8    		;Yes => ADD8
  015E   2DA0 0330              	CALL 	@SLEFT      		;Shift left one bit
  0162   D02D 000F              	MOVB	@2*R7+1(WP),R0
  0166   0240 8000              	ANDI	R0,08000H 		;Is exponent -128?
  016A   1305                    	JEQ		ADDZ     		;No  => AC zero
  016C   0220 FF00              	AI	  	R0,-1*256 		;Subtract 1 from the exponent
  0170   DB40 000F              	MOVB	R0,@2*R7+1(WP)	;Update exponent
  0174   10F1                   	JMP		ADD7
                        
  0176   2DA0 030C      ADDZ:   	CALL 	@ZERO
                        
  017A   0084           ADD8:   	LST		R4         		;Get sign
  017C   1802           ADD9:   	JOC		ADD9A    		;Carry => negative
  017E   0C0A 01C5              	TCMB	R5,7			;Clear sign bit
  0182   04C0           ADD9A:  	CLR		R0
  0184   0580           			INC		R0				;Clear carry flags if needed
                        ;
                        ;  Common routine need to check if it is correct
                        ;
  0186   2DA0 03B4      ADD10:  	CALL	@EXX       		;Fetch AC (FROM ADD5: Need to check)
  018A   2E47                   	POP  	R7
  018C   2E46                   	POP  	R6
  018E   2E45                   	POP  	R5
  0190   2DA0 03B4              	CALL	@EXX
  0194   2DC0                   	RET
                        
                        
                        ;
                        ;Add AC 'to AC..Result in AC
                        ;
                        
  0196   04C0           ADDAC:  	CLR		R0				;This is the carry register
  0198   B1C3           			AB		R7',R7
  019A   1702           			JNC		AAC1
  019C   0580           			INC		R0
  019E   1001           			JMP		AAC1A
  01A0   04C0           AAC1:   	CLR		R0				;Just in case it is coming from another routin
  01A2   A182           AAC1A:		A		R6',R6
  01A4   A180           			A		R0,R6			;Add carry from previous operation
  01A6   04C0           			CLR		R0				;Clearing R0 does not affect Status Register
  01A8   1701           			JNC		AAC2
  01AA   0580           			INC		R0
  01AC   A141           AAC2:	    A		R5',R5
  01AE   A140            			A		R0,R5			;Add carry if applicable
  01B0   2DC0                       RET
                        
                        ;
                        ;Subtract AC'from AC.
                        ;
  01B2   04C0           SUBAC:  	CLR		R0				;This is the carry register
  01B4   1702           			JNC		SAC1
  01B6   0580           			INC		R0
  01B8   1001           			JMP		SAC1A
  01BA   04C0           SAC1:   	CLR		R0				;Just in case it is coming from another routin
  01BC   6182           SAC1A:		S		R6',R6
  01BE   6180                   	S		R0,R6			;Add carry from previous operation
  01C0   04C0           			CLR		R0				;Clearing R0 does not affect Status Register
  01C2   1701           			JNC		SAC2
  01C4   0580           			INC		R0
  01C6   6141           SAC2:	    S		R5',R5
  01C8   6140            			S		R0,R5			;Add carry if applicable
  01CA   2DC0            			RET
                        ;
                        ;Compare AC to AC '
                        ;
  01CC   8045           CMPAC:  	C		R5,R5'
  01CE   1603           			JNE		CMP_RET
  01D0   8086           			C		R6,R6'
  01D2   1601           			JNE		CMP_RET
  01D4   80C7           			C		R7,R7'
  01D6   2DC0           CMP_RET:  	RET
                        ;
                        ;	Double precision comparisons
                        ;
                        ;	each compares top of stack
                        ;	(under two return addresses) to FA
                        ;
                        ;TOS >= FA?
                        ;
  01D8   2DA0 0212      _fpge::		CALL	@DCOMPAR
  01DC   1305           			JEQ		YES			;z => equal
  01DE   1303           			JEQ		DG			;remaining tests are shared
                        ;
                        ;TOS > FA?
                        ;
  01E0   2DA0 0212      _fpgt::		CALL	@DCOMPAR
  01E4   130C           			JEQ		NO			;z => equal
  01E6   100B           DG:			JMP		NO			;p => not greater than
  01E8   0204 0001      YES:		LI		R4,1		;load "true"
  01EC   2DC0           			RET
                        
                        ;
                        ;TOS <= FA?
                        ;
  01EE   2DA0 0212      _fple::		CALL	@DCOMPAR
  01F2   13FA           			JEQ		YES
  01F4   1003           			JMP		DL
                        ;
                        ;TOS < FA?
                        ;
  01F6   2DA0 0212      _fplt::		CALL	@DCOMPAR
  01FA   1301           			JEQ		NO
  01FC   11F5           DL:			JLT		YES			;p => less than
  01FE   04C4           NO:			CLR		R4			;load "false"
  0200   2DC0           			RET
                        ;
                        ;TOS == FA?
                        ;
  0202   2DA0 0212      _fpeq::		CALL	@DCOMPAR
  0206   13F0           			JEQ		YES
  0208   10FA           			JMP		NO
                        
                        ;
                        ;TOS != FA?
                        ;
  020A   2DA0 0212      _fpne::		CALL	@DCOMPAR
  020E   13EC           			JEQ		YES
  0210   10F6           			JMP		NO
                        
                        
                        ;
                        ;FLOATING POINT COMPARE.  TEST IF EQUAL.
                        ;
                        ;common routine to perform double precision comparisons
                        
                        
                        DCOMPAR:
  0212   2E40           			POP		R0	;save 1st return addr
  0214   2E41           			POP		R1	;save 2nd return addr
  0216   2E47           			POP		R7  ;get number to compare
  0218   2E46           			POP		R6
  021A   2E45           			POP		R5
  021C   2E01           			PUSH	R1	;replace 2nd addr
  021E   2E00           			PUSH	R0	;replace 1st addr, fall into...
                        CMP:
  0220   2DC0            			RET
                        ;		EXX             ;Er fortegn ens?
                        ;        LD   A,B
                        ;        EXX
                        ;        XOR  B
                        ;        JP   P,CMP1     ;Ja => CMP1
                        ;        LD   A,B        ;Fortegn fra AC til
                        ;        RLA             ;carry
                        ;        RET
                        
                        CMP1: ;  BIT  7,B        ;Negative tal?
                         ;       JR   Z,CMP2     ;Nej => CMP2
                        
                        ;        CALL CMP2       ;Sammenlign abs.vaerdi
                         ;       RET  Z          ;Ens => Returner
                        ;        CCF             ;Complementer resultat
                        ;        RET
                        
                        CMP2:;   LD   A,L        ;Er exponenter ens?
                        ;        EXX
                        ;        CP   L
                        ;        EXX
                        ;        RET  NZ         ;Nej => Returner
                        ;        OR   A          ;Er exponenter nul?
                        ;        RET  Z          ;Ja => Returner
                        ;        JP   CMPAC      ;Sammenlign AC med AC'
                        
                        
                        ;
                        ;CONVERT A FLOATING POINT A 16 BIT INTEGER USES R5, R6 and R7
                        ;
                        
  0222   0204 8001      INT:    	LI		R4,256*EXPN+1
  0226   D02D 000B      			MOVB	@2*R5+1(WP),R0      ;Is exponentially smaller
  022A   7100                   	SB  	R0,R4 				;than zero?
  022C   1702                   	JNC		INT1A
  022E   0460 030C              	B		@ZERO     			;Yes => Result zero
                        
  0232   0584           INT1A:      INC  	R4
                        
  0234   2DA0 03B4              	CALL	@EXX             	;Save to AC'
  0238   2E05                   	PUSH 	R5					;Don't know what this does, but needed for ADD10
  023A   2E06                   	PUSH 	R6
  023C   2E07                   	PUSH 	R7
  023E   2DA0 03C8              	CALL	@EXSR
  0242   2DA0 030C              	CALL 	@ZERO       			;Reset AC'
  0246   2DA0 03C8              	CALL	@EXSR
                        
  024A   0700           INT1:   	SETO	R0					;By setting the carry flag sets all the bits that have
  024C   0580           			INC		R0					;and an exponent larger
  024E   2DA0 0318              	CALL 	@RIGHT      			;than or equal to zero
  0252   0604                   	DEC  	R4
  0254   16FA                   	JNE		INT1
                        
  0256   5B6D 0007              	SZCB	@2*R7'+1(WP),@2*R7+1(WP)   	;We now have AC so reset all bits in AC
  025A   000F           
  025C   4182                   	SZC		R6',R6					  	;that has an exponent
  025E   41C3                   	SZC		R7',R7						;less than using AND
  0260   2DA0 03B4              	CALL	@EXX						;Now have AC
  0264   0460 0186      INT2:   	B		@ADD10      				;Get AC '
                        
                        
                        ;
                        ;	negate FA, and push address of MINUSFA
                        ;	called to evaluate functions f(x) when the argument is
                        ;	negative and f() satisfies f(-x)=-f(x)
                        ;
  0268   2DA0 0276      ODD:		CALL	@MINUSFPA
  026C   0200 0276      			LI		R0,MINUSFPA
  0270   C11A           			MOV		*SP,R4
  0272   C680           			MOV		R0,*SP
  0274   0454           			B		*R4
                        
  0276   D120 0006      MINUSFPA: 	MOVB	@FPA,R4
  027A   0200 8000      			LI		R0,SIGN*256
  027E   2900           			XOR		R0,R4
  0280   D804 0006      			MOVB	R4,@FPA
  0284   2DC0           			RET
                        
                        ;
                        ;FLOATING POINT SUBTRACTION
                        ;
  0286   2E44           _fpsub::   	POP		R4				;save return address
  0288   2E47           			POP		R7
  028A   2E46           			POP		R6
  028C   2E45           			POP		R5
  028E   2E04           			PUSH	R4				;replace return address
  0290   02AD           			STWP	WP				;Need to offset into wp for some operations
                        
  0292   0C09 01C5      			TMB		R5,7			;Is AC negative?
  0296   1302           			JEQ		SUB1
  0298   0460 00CE              	B		@ADD1    		;Ja => ADD1
                        
  029C   2DA0 02A4      SUB1:   	CALL 	@FPNEG      	;AC=-AC
  02A0   2DA0 00CE              	CALL 	@ADD1       	;Load AC' into  AC
                        
  02A4   D06D 000F      FPNEG:  	MOVB	@2*R7+1(WP),R1   ;Is AC zero?
  02A8   1305                   	JEQ		FP_RET      	 ;Yes => Return
  02AA   C045                   	MOV		R5,R1      		 ;Complement sign
  02AC   0200 8000              	LI		R0,SIGN*256
  02B0   2801                  	 	XOR  	R1,R0
  02B2   D141                  	 	MOVB	R1,R5
  02B4   2DC0           FP_RET:   	RET
                        
                        ;
                        ; INVERT THE SIGN BIT OF THE NUMBER IN THE FPA.
                        ;
  02B6   D060 0001      _minusfa::	MOVB	@R5',R1
  02BA   0C09 01C1      			TMB		R1,7
  02BE   1603           			JNE		MINUS1
  02C0   0C0A 01C1      			TCMB	R1,7			;WAS ONE SO CLEAR IT
  02C4   1002           			JMP		MINUS2
  02C6   0C0B 01C1      MINUS1:		TSMB	R1,7			;WAS ZERO SO SET IT
  02CA   D801 0001      MINUS2:		MOVB	R1,@R5'			;MAKE IT SO
  02CE   2DC0           			RET
                        
                        
                        ; CONVERT THE 16-BIT INTEGER IN R4 WITH 2'S COMPLEMENT SIGN
                        ; TO FLOATING POINT NUMBER AND PLACE IN FPA.
                        
                        float::
  02D0   02AD           _float::	STWP	WP			;We may need this
  02D2   C104           			MOV		R4,R4        ;Is R4=0?
  02D4   131B                   	JEQ		ZERO         ;YES => ZERO
                        
  02D6   0C09 01C4      			TMB		R4,7		;Is bit 8 negative?
  02DA   1601           			JNE		FLT1		;No => FLT1
  02DC   0504           			NEG		R4			;Take 2's complemnet ST2 is unchanged
                        
  02DE   02CF           FLT1:  	 	STST 	ST			;Save sign in R0 via status register
  02E0   C144                   	MOV		R4,R5		;Set mantissa
  02E2   04C6                   	CLR		R6
  02E4   04C7                   	CLR		R7
  02E6   0204 0090              	LI		R4,EXPN+16	;Set inital value of exponent so we can normalise
                        
  02EA   0C09 01C5      FLT2:   	TMB		R5,7        ;Now inovke the Normaliser
  02EE   1304                   	JEQ		FLT3		;If MSB is set then we have finished?
  02F0   2DA0 0330              	CALL 	@SLEFT		;No, so move R5,R6 and R7 one position to the left
  02F4   0604                   	DEC  	R4			;Adjuat the exponent
  02F6   10F9                   	JMP		FLT2
                        
  02F8   DB6D 0009      FLT3:   	MOVB	@2*R4+1(WP),@2*R7+1(WP)  ;Update the exponent
  02FC   000F           
  02FE   008F           			LST		ST     		;Was the original integer value negative?
  0300   1302                   	JEQ		FLT4   		;Yes => Return
  0302   0245 7FFF              	ANDI	R5,7FFFH	;Clear Most Significant sign Bit
  0306   2DA0 03DE      FLT4:      	CALL	@PUTAC		;Save the number in the FPA
  030A   2DC0                 		RET
                        
                        ;
                        ;Reset AC. (R5, R6 and R7)
                        ;
  030C   04C5           ZERO:   	CLR		R5  		;Reset carry, exponent of mantissa      ;
  030E   04C6                   	CLR		R6
  0310   04C7                   	CLR		R7
  0312   2DA0 03DE              	CALL	@PUTAC		;Save the number in the FPA
  0316   2DC0           	        RET
                        
                        ;
                        ;Rotate AC to the right - not concerned with carry into LSB (exp) R7
                        ;
                        SRIGHT:
  0318   C047           RIGHT: 		MOV		R7,R1		;Preserve R7 and shift copy in R1
  031A   0911             			SRL		R1,1		;Not concerned about carry for R7
  031C   D1C1           			MOVB	R1,R7		;Restore R7 and the exponent and Now check for R6 carry into R7
  031E   0916           			SRL		R6,1		;If carry we need to add to R7
  0320   1702           			JNC		RSR5
  0322   0C0B 01C7      			TSMB	R7,7		;Set MSB due to carry over
  0326   0915           RSR5:		SRL		R5,1
  0328   1702           			JNC		RSR6
  032A   0C0B 01C6      			TSMB	R6,7		;Set MSB due to carry over from R5
  032E   2DC0           RSR6:		RET
                        
                        
                        ;
                        ;Rotate AC to the left.
                        ;
                        
  0330   04C1           SLEFT:  	CLR		R1
  0332   0A15           LEFT:   	SLA		R5,1			;R5 HOLDS THE MSB OF THE FP
  0334   0A16           			SLA		R6,1			;SHIFT R5,R6 AND R7 TO THE LEFT ONE BIT
  0336   1701           			JNC		LSR7
  0338   0585           			INC		R5				;Add the carry to R5
  033A   C047           LSR7:		MOV		R7,R1			;Need to preserve exponent
  033C   0241 00FF      			ANDI	R1,0FFH			;Clear this for OR
  0340   0247 FF00      			ANDI	R7,0FF00H		;Clear exponent ready for shift
  0344   0A17           			SLA		R7,1
  0346   1701           			JNC		LSR8
  0348   0586           			INC		R6
  034A   E1C1           LSR8:		SOC		R1,R7			;OR back in exponent
  034C   2DC0           			RET
                        
                        ;
                        ;
                        ;FLOATING POINT TO 16-BIT INTEGER (IN FPA ) WITH
                        ;2'S COMPLEMENT FORMAT.  THE BITS THAT WE NEED TO GRAB ARE IN THE MSB OF THE
                        ;FLOATING POINT REPRESENTATION, I.E.  REGISTERS R5 AND R6
                        ;
  034E   2DA0 03D0      ifix::		CALL	@GETAC			;Get FPA into R5, R6 and R7
  0352   0C09 01ED      FIX:		TMB		@2*R7+1(WP),7   ;Exponent < 0?
  0356   000F           
  0358   131E                   	JEQ		FIX4     		;Yes => FIX4
                        
  035A   0C0B 01C5              	TSMB	R5,7			;Test and set sign bit
  035E   02CF                   	STST	ST				;Save the test of the sign
  0360   C107                   	MOV		R7,R4			;Save copy of exponent
  0362   06C4                   	SWPB	R4
                        
  0364   0200 008F      FIX1:   	LI		R0,EXPN+15		;Test exponent to see if it is (0x8F)
  0368   06C0           			SWPB	R0				;too large to be an integer
  036A   9B40 000F      FIX1B:      CB		R0,@2*R7+1(WP)	;
  036E   1701                   	JNC		FIX1A
  0370   2DC0                   	RET						;EXP>15 => overflow
  0372   1307           FIX1A:      JEQ		FIX2			;EXP=15 => FIX2
  0374   2DA0 0318              	CALL 	@SRIGHT     		;EXP<15 => rotate to
  0378   0224 0100              	AI		R4,256		  	;right and add 1 more to
  037C   DB44 000F              	MOVB	R4,@2*R7+1(WP)	;Update exponent
  0380   10F4                   	JMP   	FIX1B       	;exponent
                        
  0382   2DA0 0318      FIX2:   	CALL 	@SRIGHT     		;Rotate to the right
  0386   008D                   	LST		WP				;Load status register from first test
  0388   1304                   	JEQ   	FIX3     		;Negative sign?  No => INT2
  038A   0504                   	NEG		R4       		;Convert to 2's complement
  038C   04C0                   	CLR		R0				;Clear for carry flag
  038E   0580                   	INC		R0
  0390   2DC0                   	RET
                        
  0392   C105           FIX3:   	MOV		R5,R4        	;Get the final integer into R4
  0394   2DC0                   	RET
                        
  0396   04C4           FIX4:   	CLR		R4       		;Underflow, return -32768
  0398   2DC0                   	RET
                        
                        
                        ;
                        ;	return -(floor(-x))
                        ;
                        CEIL::
  039A   2DA0 0268      _ceil::		CALL	@ODD
                        ;
                        ;   Return largest integer not greater than floor(x) returns the nearest
                        ;  integral value that is not greater than x. It is always true that
                        ;  floor(x) <= x
                        ;
                        ;  see https://stackoverflow.com/questions/24158625/is-it-possible-for-floor-to-return-an-inaccurate-result-due-to-floating-point#:~:text=The%20floor()%20function%20returns,that%20
                        
                        ;floor(x) <= x
                        FLOOR::
                        _floor::
  039E   D120 000B      			MOVB	@FPA+5,R4		;fetch exponent
  03A2   0284 D900      			CI		R4,	0D9H*256	;(was A8H) larget negative exponent
  03A6   D060 0006      			MOVB	@FPA,R1
  03AA   1801           			JOC		FLR1
  03AC   2DC0           			RET						;nc => binary point is right of lsb
  03AE   2DA0 0222      FLR1:		CALL	@INT
  03B2   2DC0           			RET
                        ;
                        ;Set carry if the grade in A is a digit.
                        
                        ;GDTST:  	LD   A,(IX+0)
                        ;DIGTST: 	SUB  '0'
                        ;        	CCF
                         ;       	RET  NC
                        ;        	CP   10
                        ;        	RET
                        ;
                        ;DUPLICATE EQUIVALENT TO Z80 EXX
                        ;
  03B4   C005           EXX:		MOV		R5,R0
  03B6   C141           			MOV		R5',R5
  03B8   C040           			MOV		R0,R5'
                        
  03BA   C006           			MOV		R6,R0
  03BC   C182           			MOV		R6',R6
  03BE   C080           			MOV		R0,R6'
                        
  03C0   C007           			MOV		R7,R0
  03C2   C1C3           			MOV		R7',R7
  03C4   C0C0           			MOV		R0,R7'
  03C6   2DC0           			RET
                        
                        		;STILL DECIDING WHICH APPROACH TO TAKE
                        
                        ;			MOV		R5,R1
                        ;			MOV		R6,R2
                        ;			MOV		R7,R3
                        ;			MOV		@R5P,R5
                        ;			MOV		@R6P,R6
                        ;			MOV		@R7P,R7
                        ;			MOV		R1,@R5P(R5)
                        ;			MOV		R2,@R6P(R6)
                        ;			MOV		R3,@R7P(R7)
                        ;			RET
                        
                        
                        ;
                        ;DUPLICATE EQUIVALENT TO Z80 EX FOR EXCHANGING STATUS REGISTERS
                        ;
  03C8   02C0           EXSR:		STST	R0			;SAVE CURRENT STATUS REGISTER
  03CA   008F           			LST		ST			;LOAD PREVIOUS STATUS REGISTER
  03CC   C3C0           			MOV		R0,ST		;SAVE CURRENT STATUS REGISTER IN SR
  03CE   2DC0           			RET
                        ;
                        ;GET FLOATING POINT NUMBER FROM FPA CONTENTS INTO R5, R6 AND R7
                        ;
  03D0   C160 0006      GETAC:		MOV		@FPA,R5
  03D4   C1A0 0008      			MOV		@FPA+2,R6
  03D8   C1E0 000A      			MOV		@FPA+4,R7
  03DC   2DC0           			RET
                        ;
                        ;GET FLOATING POINT NUMBER FROM FPA CONTENTS INTO R5, R6 AND R7
                        ;
  03DE   C805 0006      PUTAC:		MOV		R5,@FPA
  03E2   C806 0008      			MOV		R6,@FPA+2
  03E6   C807 000A      			MOV		R7,@FPA+4
  03EA   2DC0           			RET
                        ;
                        ;Set AC light 1.
                        ;
                        
  03EC   0205 0000      AC1:    	LI		R5,00000H
  03F0   0206 0000              	LI		R6,00000H
  03F4   0207 0081              	LI		R7,00081H
  03F8   2DC0                   	RET
                        ;
  03FA                          	END

No error(s).
DL                01FC    R6                0006    FLT1              02DE    WP                000D
AAC1A             01A2    R7                0007    CALL              2D80    RIGHT             0318
DCOMPAR           0212    INT               0222    SRIGHT            0318    AC1               03EC
FIX1B             036A    EXX               03B4    _fpeq             0202    INT1              024A
EXTRA             0000    INT2              0264    SIGN              0080    _fload            004C
ADD2              00EC    LEFT              0332    ADD3              0114    _fpgt             01E0
_ceil             039A    R11               000B    SUB1              029C    _float            02D0
ADD7              0158    ADDAC             0196    GRIPE             0046    _fplt             01F6
FP_RET            02B4    SUBAC             01B2    FPNEG             02A4    ODD               0268
DSIGN             000C    FLR1              03AE    ADD2A             010A    ifix              034E
_floor            039E    CMP               0220    SAC1              01BA    _fpush            006E
CMPAC             01CC    INT1A             0232    SLEFT             0330    FIX               0352
IWIDTH            00F0    GETAC             03D0    ZERO              030C    CMP1              0222
FLOOR             039E    CMP2              0222    OFLOW             002E    float             02D0
R0                0000    FIX1              0364    CEIL              039A    FIX2              0382
R3                0003    SP                000A    R5                0005    FIX4              0396
FLT2              02EA    FIX3              0392    FLT3              02F8    ST                000F
_fpsub            0286    PUSH              2E00    ADD10             0186    EXSR              03C8
ADD1              00CE    ILLFCT            0018    ADD4              0124    R5'               0001
ADD6              0154    R6'               0002    ADD9              017C    R7'               0003
EXPN              0080    LSR7              033A    ADDZ              0176    MINUS2            02CA
SAC2              01C6    MINUS1            02C6    SAC1A             01BC    LSR8              034A
PUTAC             03DE    FWIDTH            000F    _fstore           0058    NO                01FE
R2                0002    _fpdiv            004A    WHEX              2E80    DIVZERO           000E
FLT4              0306    _fpadd            00B8    POP               2E40    MINUSFPA          0276
ADD5              0146    _fpge             01D8    RET               2DC0    CMP_RET           01D6
ADD9A             0182    _fple             01EE    _fpswap           004A    FIX1A             0372
R1                0001    _fpne             020A    _fpush2           0084    _fldpsh           0064
_minusfa          02B6    RSR5              0326    ADD1A             00D8    RSR6              032E
_fpmul            004A    ADD8              017A    YES               01E8    R4                0004
AAC1              01A0    AAC2              01AC    DG                01E6    FPA               0006
